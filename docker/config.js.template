// Runtime configuration template for Docker deployment
// Environment variables are substituted by docker-entrypoint.sh at container startup
//
// Docker Environment Variables:
//   DEFAULT_ARCHIVE_URL    - Archive container file (.a3d, .a3z) - takes priority
//   DEFAULT_SPLAT_URL      - Default splat file to load
//   DEFAULT_MODEL_URL      - Default model file to load
//   DEFAULT_POINTCLOUD_URL - Default E57 point cloud file to load
//   SHOW_CONTROLS          - Show (true) or hide (false) the controls panel
//   ALLOWED_DOMAINS        - Comma-separated list of trusted external domains
//                            Supports wildcards: *.cdn.example.com
//   KIOSK_LOCK             - When "true", forces kiosk mode and ignores privilege-escalating
//                            URL params (?controls, ?sidebar, ?toolbar, ?kiosk, ?splat, etc.)
//   ARCHIVE_PATH_PREFIX    - When set with KIOSK_LOCK, only archives under this path are allowed
//                            (e.g., "/archives/"). Prevents path traversal to other server files.
//   LOD_BUDGET_SD          - Splat LOD budget for SD quality tier (default: 500000)
//   LOD_BUDGET_HD          - Splat LOD budget for HD quality tier (default: 3000000)
//   EMBED_REFERERS         - Space-separated list of allowed referer domains for nginx
//                            (e.g., "client-site.com *.client-site.com")
//
// URL parameters can override environment defaults:
//   ?archive=URL     - Archive container file (.a3d, .a3z) - takes priority
//   ?splat=URL       - Splat file to load
//   ?model=URL       - Model file to load
//   ?pointcloud=URL  - E57 point cloud file to load
//   ?alignment=URL   - Alignment JSON file to load
//   ?controls=MODE   - Control panel mode: full, minimal, none
//   ?mode=VIEW       - Initial view mode: splat, model, both, split
//   ?toolbar=MODE    - Toolbar mode: show, hide
//   ?sidebar=MODE    - Sidebar mode: closed, view, edit
//   ?autoload=BOOL   - Auto-load archive: true (default), false (show click-to-load gate)
//
// Inline alignment params:
//   ?sp=x,y,z  - Splat position    ?mp=x,y,z  - Model position    ?pp=x,y,z  - Point cloud position
//   ?sr=x,y,z  - Splat rotation    ?mr=x,y,z  - Model rotation    ?pr=x,y,z  - Point cloud rotation
//   ?ss=scale  - Splat scale       ?ms=scale  - Model scale       ?ps=scale  - Point cloud scale
//
// Security:
//   By default, only same-origin URLs are allowed. To allow external domains,
//   add them to the ALLOWED_EXTERNAL_DOMAINS array below.

(function() {
    // Parse URL parameters
    const params = new URLSearchParams(window.location.search);

    // =========================================================================
    // URL VALIDATION - Security measure to prevent loading from untrusted sources
    // =========================================================================

    // Add trusted external domains here (e.g., CDN hosts, trusted APIs)
    // Same-origin URLs are always allowed
    // Additional domains can be added at deploy time via ALLOWED_DOMAINS env var
    const envAllowedDomains = "${ALLOWED_DOMAINS}";
    const ALLOWED_EXTERNAL_DOMAINS = [
        // 'trusted-cdn.example.com',
        // 'assets.mycompany.com',
    ].concat(
        envAllowedDomains ? envAllowedDomains.split(',').map(d => d.trim()).filter(Boolean) : []
    );

    // =========================================================================
    // KIOSK EMBED SECURITY — Server-side lockdown for iframe deployments
    // =========================================================================
    // When KIOSK_LOCK is true: forces kiosk mode, ignores privilege-escalating URL params
    // When ARCHIVE_PATH_PREFIX is set: only archives under that path prefix are allowed
    const KIOSK_LOCK = "${KIOSK_LOCK}" === "true";
    const ARCHIVE_PATH_PREFIX = "${ARCHIVE_PATH_PREFIX}";

    if (KIOSK_LOCK) {
        console.info('[config] KIOSK_LOCK is ACTIVE — editor params disabled');
        if (ARCHIVE_PATH_PREFIX) {
            console.info('[config] ARCHIVE_PATH_PREFIX:', ARCHIVE_PATH_PREFIX);
        }
    }

    /**
     * Validates a URL parameter to prevent SSRF and malicious URL injection.
     *
     * @param {string} urlString - The URL string to validate
     * @param {string} paramName - Name of the parameter (for logging)
     * @returns {string} - Validated URL string, or empty string if invalid
     */
    function validateUrl(urlString, paramName) {
        if (!urlString || urlString.trim() === '') {
            return '';
        }

        try {
            // Parse the URL (relative URLs resolved against current origin)
            const url = new URL(urlString, window.location.origin);

            // Block dangerous protocols (javascript:, data:, vbscript:, etc.)
            const allowedProtocols = ['http:', 'https:'];
            if (!allowedProtocols.includes(url.protocol)) {
                console.warn(`[config] Blocked unsafe protocol for ${paramName}:`, url.protocol);
                return '';
            }

            // Check if same-origin
            const isSameOrigin = url.origin === window.location.origin;

            // Check if domain is in allowed list
            const isAllowedExternal = ALLOWED_EXTERNAL_DOMAINS.some(domain => {
                // Support wildcard subdomains (*.example.com)
                if (domain.startsWith('*.')) {
                    const baseDomain = domain.slice(2);
                    return url.hostname === baseDomain || url.hostname.endsWith('.' + baseDomain);
                }
                return url.hostname === domain;
            });

            if (!isSameOrigin && !isAllowedExternal) {
                console.warn(`[config] Blocked external URL for ${paramName}:`, url.hostname);
                console.info(`[config] To allow this domain, add '${url.hostname}' to ALLOWED_EXTERNAL_DOMAINS in config.js`);
                return '';
            }

            // Enforce HTTPS for external URLs in production (when page is served over HTTPS)
            if (!isSameOrigin && window.location.protocol === 'https:' && url.protocol !== 'https:') {
                console.warn(`[config] Blocked insecure external URL for ${paramName} (HTTPS required):`, urlString);
                return '';
            }

            // URL is valid
            console.info(`[config] Validated ${paramName}:`, url.href);
            return url.href;

        } catch (e) {
            console.warn(`[config] Invalid URL for ${paramName}:`, urlString, e.message);
            return '';
        }
    }

    /**
     * Validates that an archive URL path starts with ARCHIVE_PATH_PREFIX.
     * Only enforced when KIOSK_LOCK is true AND ARCHIVE_PATH_PREFIX is set.
     * Uses new URL() to normalize path traversal attempts (../).
     *
     * @param {string} urlString - Already-validated URL string from validateUrl()
     * @param {string} paramName - Name of the parameter (for logging)
     * @returns {string} - The URL if allowed, or empty string if blocked
     */
    function validateArchivePath(urlString, paramName) {
        if (!urlString || !KIOSK_LOCK || !ARCHIVE_PATH_PREFIX) {
            return urlString;
        }

        try {
            const url = new URL(urlString, window.location.origin);
            // new URL() normalizes ../ traversals, so /archives/../secrets/x becomes /secrets/x
            const normalizedPath = url.pathname;

            if (!normalizedPath.startsWith(ARCHIVE_PATH_PREFIX)) {
                console.warn(`[config] Blocked archive outside prefix for ${paramName}: ${normalizedPath} (required prefix: ${ARCHIVE_PATH_PREFIX})`);
                return '';
            }

            return urlString;
        } catch (e) {
            console.warn(`[config] Invalid archive path for ${paramName}:`, urlString, e.message);
            return '';
        }
    }

    // Helper to parse comma-separated numbers
    function parseVec3(str) {
        if (!str) return null;
        const parts = str.split(',').map(s => parseFloat(s.trim()));
        if (parts.length === 3 && parts.every(n => !isNaN(n))) {
            return parts;
        }
        return null;
    }

    // Clean URL injection (set by meta-server for /view/{hash} routes)
    const _inj = window.__VITRINE_CLEAN_URL || {};

    // Server-Side Defaults (Injected by Docker)
    const envArchive = "${DEFAULT_ARCHIVE_URL}";
    const envSplat = "${DEFAULT_SPLAT_URL}";
    const envModel = "${DEFAULT_MODEL_URL}";
    const envPointcloud = "${DEFAULT_POINTCLOUD_URL}";
    const envAlignment = "";
    const envShowControls = ${SHOW_CONTROLS}; // This becomes true/false
    const envLodBudgetSd = "${LOD_BUDGET_SD}";
    const envLodBudgetHd = "${LOD_BUDGET_HD}";

    // Get and validate URL parameters (URL params override env defaults)
    // When KIOSK_LOCK is active: archive URL param still works (needed for per-embed URLs)
    // but splat/model/pointcloud/alignment are locked to env defaults only
    const archiveUrl = validateArchivePath(
        validateUrl(params.get('archive') || _inj.archive || envArchive, 'archive'),
        'archive'
    );
    const splatUrl = validateUrl(KIOSK_LOCK ? envSplat : (params.get('splat') || envSplat), 'splat');
    const modelUrl = validateUrl(KIOSK_LOCK ? envModel : (params.get('model') || envModel), 'model');
    const pointcloudUrl = validateUrl(KIOSK_LOCK ? envPointcloud : (params.get('pointcloud') || envPointcloud), 'pointcloud');
    const alignmentUrl = validateUrl(KIOSK_LOCK ? envAlignment : (params.get('alignment') || envAlignment), 'alignment');

    // Kiosk mode — forced true when KIOSK_LOCK is active, or via clean URL injection
    const kioskMode = KIOSK_LOCK || params.get('kiosk') === 'true' || (!params.has('kiosk') && _inj.kiosk === true);

    // Control and view mode settings (kiosk and KIOSK_LOCK override defaults)
    const urlControls = params.get('controls'); // 'full', 'minimal', 'none', or null
    const controlsMode = KIOSK_LOCK ? 'none' : (kioskMode ? 'none' : (urlControls || 'full'));
    const viewMode = params.get('mode') || (kioskMode ? 'both' : 'model'); // splat, model, pointcloud, both, split
    const toolbarMode = KIOSK_LOCK ? 'show' : (kioskMode ? 'show' : (params.get('toolbar') || 'show')); // show, hide
    const sidebarMode = KIOSK_LOCK ? 'closed' : (kioskMode ? 'closed' : (params.get('sidebar') || 'closed')); // closed, view, edit
    const autoload = params.has('autoload') ? params.get('autoload') !== 'false' : (_inj.autoload !== undefined ? _inj.autoload : true);

    // Parse inline alignment params
    const splatPos = parseVec3(params.get('sp'));
    const splatRot = parseVec3(params.get('sr'));
    const splatScale = params.get('ss') ? parseFloat(params.get('ss')) : null;
    const modelPos = parseVec3(params.get('mp'));
    const modelRot = parseVec3(params.get('mr'));
    const modelScale = params.get('ms') ? parseFloat(params.get('ms')) : null;
    const pcPos = parseVec3(params.get('pp'));
    const pcRot = parseVec3(params.get('pr'));
    const pcScale = params.get('ps') ? parseFloat(params.get('ps')) : null;

    // Build inline alignment object if any params are present
    let inlineAlignment = null;
    if (splatPos || splatRot || splatScale !== null || modelPos || modelRot || modelScale !== null || pcPos || pcRot || pcScale !== null) {
        inlineAlignment = {};
        if (splatPos || splatRot || splatScale !== null) {
            inlineAlignment.splat = {
                position: splatPos || [0, 0, 0],
                rotation: splatRot || [0, 0, 0],
                scale: splatScale !== null && !isNaN(splatScale) ? splatScale : 1
            };
        }
        if (modelPos || modelRot || modelScale !== null) {
            inlineAlignment.model = {
                position: modelPos || [0, 0, 0],
                rotation: modelRot || [0, 0, 0],
                scale: modelScale !== null && !isNaN(modelScale) ? modelScale : 1
            };
        }
        if (pcPos || pcRot || pcScale !== null) {
            inlineAlignment.pointcloud = {
                position: pcPos || [0, 0, 0],
                rotation: pcRot || [0, 0, 0],
                scale: pcScale !== null && !isNaN(pcScale) ? pcScale : 1
            };
        }
    }

    window.APP_CONFIG = {
        kiosk: kioskMode,
        defaultArchiveUrl: archiveUrl,
        defaultSplatUrl: splatUrl,
        defaultModelUrl: modelUrl,
        defaultPointcloudUrl: pointcloudUrl,
        defaultAlignmentUrl: alignmentUrl,
        inlineAlignment: inlineAlignment,

        // Logic: Show controls if Env says yes AND URL doesn't explicitly say 'none'
        showControls: kioskMode ? true : (envShowControls && urlControls !== 'none'),

        // Control panel mode
        controlsMode: controlsMode,

        // Initial view mode
        initialViewMode: viewMode,

        // Viewer mode settings
        showToolbar: toolbarMode !== 'hide',
        sidebarMode: sidebarMode, // closed, view, edit

        // Theme and layout (cosmetic, allowed even when locked)
        theme: params.get('theme') || _inj.theme || '',
        layout: params.get('layout') || '',
        autoload: autoload, // false = show click-to-load gate before downloading

        // Kiosk embed security
        kioskLock: KIOSK_LOCK,

        // Allowed external domains (shared with main.js URL validation)
        allowedDomains: ALLOWED_EXTERNAL_DOMAINS,

        // LOD splat budgets (overrides quality-tier.ts defaults)
        lodBudgetSd: envLodBudgetSd ? parseInt(envLodBudgetSd, 10) || 0 : 0,
        lodBudgetHd: envLodBudgetHd ? parseInt(envLodBudgetHd, 10) || 0 : 0,

        // Library (archive management) — enabled when ADMIN_ENABLED=true
        libraryEnabled: "${ADMIN_ENABLED}" === "true",

        // Chunked upload — splits large files into 50 MB chunks to work around
        // Cloudflare Tunnel's 100 MB per-request body limit (CHUNKED_UPLOAD=true)
        chunkedUpload: "${CHUNKED_UPLOAD}" === "true"
    };

    console.log('[config.js] Generated Config:', window.APP_CONFIG);
})();
